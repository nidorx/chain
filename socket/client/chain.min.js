let Options={Debug:!0};var MessageKindEnum,ChannelStateEnum,SocketStateEnum;(MessageKindEnum=>{MessageKindEnum[MessageKindEnum.PUSH=0]="PUSH",MessageKindEnum[MessageKindEnum.REPLY=1]="REPLY",MessageKindEnum[MessageKindEnum.BROADCAST=2]="BROADCAST"})(MessageKindEnum=MessageKindEnum||{}),(ChannelStateEnum=>{ChannelStateEnum[ChannelStateEnum.CLOSED=0]="CLOSED",ChannelStateEnum[ChannelStateEnum.ERRORED=1]="ERRORED",ChannelStateEnum[ChannelStateEnum.JOINED=2]="JOINED",ChannelStateEnum[ChannelStateEnum.JOINING=3]="JOINING",ChannelStateEnum[ChannelStateEnum.LEAVING=4]="LEAVING"})(ChannelStateEnum=ChannelStateEnum||{}),(SocketStateEnum=>{SocketStateEnum[SocketStateEnum.DISCONNECTED=0]="DISCONNECTED",SocketStateEnum[SocketStateEnum.CONNECTING=2]="CONNECTING",SocketStateEnum[SocketStateEnum.CONNECTED=3]="CONNECTED",SocketStateEnum[SocketStateEnum.DISCONNECTING=4]="DISCONNECTING",SocketStateEnum[SocketStateEnum.ERRORED=5]="ERRORED"})(SocketStateEnum=SocketStateEnum||{});let SOCKET="Socket",CHANNEL="Channel",TRANSPORT="Transport";class Events{events={};emit(event,...args){for(let callbacks=this.events[event]||[],i=0,l=callbacks.length;i<l;i++)callbacks[i](...args)}on(event,callback){return this.events[event]?.push(callback)||(this.events[event]=[callback]),this}off(event,callback){event=this.events[event];event&&0<=(callback=event.indexOf(callback))&&event.splice(callback,1)}}class Socket extends Events{ref=1;state;endpoint;transport;transportListOld;disconnectIdleTimer;timeout;channels=[];duplicated;sendBuffer=[];sessionStorage;rejoinInterval;transportConfig;disconnectIdleTimeout;dropNodeConnectionAfter;constructor(options){super(),this.state=SocketStateEnum.DISCONNECTED,this.timeout=options.timeout||3e4,this.sessionStorage=options.sessionStorage||window.sessionStorage,this.transportConfig=options.transport||[{name:"SSE"}],this.rejoinInterval=options.rejoinInterval||[1e3,2e3,5e3,1e4],this.transportListOld=[],this.disconnectIdleTimeout=options.disconnectIdleTimeout||5e3,this.dropNodeConnectionAfter=options.dropNodeConnectionAfter||5e3,this.duplicated=options.duplicated||(msg=>!1);let sid=this.getSession("chain:sid"),newSid=()=>{sid=(Math.random()+1).toString(36).substring(7),this.storeSession("chain:sid",sid)},newTransport=(null==sid&&newSid(),()=>{for(let i=0;i<this.transportConfig.length;i++){var config=this.transportConfig[i];if(Transports[config.name]){this.transport=new Transports[config.name]({...config,sid:sid});break}}this.transport.on("open",this.onTransportOpen.bind(this)),this.transport.on("error",this.onTransportError.bind(this)),this.transport.on("message",this.onTransportMessage.bind(this)),this.transport.on("close",this.onTransportClose.bind(this))}),nodes=[],initTransport=node=>{if(this.transport){if(this.transport.endpoint()==node.endpoint)return;this.transportListOld.push(this.transport),newSid()}this.endpoint=node.endpoint;var transport=this.transportListOld.find(transport=>transport.endpoint()==node.endpoint);transport?(this.transportListOld.splice(this.transportListOld.indexOf(transport),1),this.transport=transport):newTransport(),this.state=SocketStateEnum.CONNECTING,this.transport.connect(this.endpoint)},tryConnectToNextNode=()=>{let next;for(let i=0;i<nodes.length;i++){var node=nodes[i];if(0==node.retry.tries()){next=node;break}(!next||next.retry.tries()>node.retry.tries())&&(next=node)}next.retry.retry()};var doGetNodes=async()=>{var endpoints=await options.getNodes();if(endpoints&&0!==endpoints.length){let currentNode,newNodes=[];if(endpoints.forEach(endpoint=>{let node=nodes.find(node=>node.endpoint==endpoint);node?node.retry.reset():node={endpoint:endpoint,retry:new Retry(retry=>{initTransport(node)},[1,500,1e3,2e3,5e3])},newNodes.push(node),this.endpoint==endpoint&&(currentNode=node)}),nodes=newNodes,currentNode!=nodes[0])return tryConnectToNextNode()}else log(SOCKET,'No nodes available for connection"')};setTimeout(doGetNodes),setInterval(doGetNodes,1e3*(options.getNodesInterval||30))}getSession(key){return this.sessionStorage.getItem(key)}storeSession(key,value){this.sessionStorage.setItem(key,value)}getTimeout(){return this.timeout}getRejoinInterval(){return this.rejoinInterval}isConnected(){return this.state==SocketStateEnum.CONNECTED}connect(){this.state!=SocketStateEnum.CONNECTED&&this.state!=SocketStateEnum.CONNECTING&&(this.state=SocketStateEnum.CONNECTING,this.transport)&&this.transport.connect(this.endpoint)}disconnect(){this.state!=SocketStateEnum.DISCONNECTED&&this.state!=SocketStateEnum.DISCONNECTING&&this.state!=SocketStateEnum.ERRORED&&(this.state=SocketStateEnum.DISCONNECTING,this.transport?this.transport.close():this.state=SocketStateEnum.DISCONNECTED)}channel(topic,params={},options={}){this.isConnected()||this.connect();topic=new Channel(topic,params,this,options);return this.channels.push(topic),this.disconnectIdleTimer&&clearTimeout(this.disconnectIdleTimer),topic}remove(channel){channel=this.channels.indexOf(channel);0<=channel&&(this.channels.splice(channel,1),0==this.channels.length)&&(this.disconnectIdleTimer=setTimeout(()=>{this.disconnect(),this.disconnectIdleTimer=void 0},this.disconnectIdleTimeout))}leave(topic){var channel=this.channels.find(chn=>chn.getTopic()===topic&&(chn.isJoined()||chn.isJoining()));channel&&(log(SOCKET,'leaving topic "%s"',topic),channel.leave())}push(message,transport){let{topic,event,payload,ref,joinRef}=message,data=encode(message);transport?(log(SOCKET,"push %s %s (%s, %s)",topic,event,joinRef,ref,payload),transport.send(data)):this.state==SocketStateEnum.CONNECTED?(log(SOCKET,"push %s %s (%s, %s)",topic,event,joinRef,ref,payload),this.transport.send(data)):(log(SOCKET,"push %s %s (%s, %s) [scheduled]",topic,event,joinRef,ref,payload),this.sendBuffer.push(()=>{log(SOCKET,"push %s %s (%s, %s)",topic,event,joinRef,ref,payload),this.transport.send(data)}))}nextRef(){return this.ref++,this.ref===Number.MAX_SAFE_INTEGER&&(this.ref=1),this.ref}onTransportOpen(transport){if(transport==this.transport&&(log(SOCKET,"connected to %s",this.endpoint),this.state=SocketStateEnum.CONNECTED,0<this.sendBuffer.length&&(this.sendBuffer.forEach(callback=>callback()),this.sendBuffer.splice(0)),this.emit("open",transport),0<this.transportListOld.length)){let old=this.transportListOld;this.transportListOld=[],setTimeout(()=>{old.forEach(transport=>{transport.close()})},this.dropNodeConnectionAfter)}}onTransportClose(transport,event){transport==this.transport?(log(SOCKET,"closed"),this.state=SocketStateEnum.DISCONNECTED,this.emit("close")):0<=(transport=this.transportListOld.indexOf(transport))&&this.transportListOld.splice(transport,1)}onTransportMessage(transport,data){data=decode(data);let{topic,event,payload,ref,joinRef}=data;log(SOCKET,"receive %s %s %s",topic||"",event||"",ref||joinRef?`(${joinRef||""}, ${ref||""})`:"",payload),this.duplicated(data)?this.emit("message:duplicated",data):(this.channels.forEach(channel=>{channel.trigger(event,payload,topic,ref,joinRef)}),this.emit("message",data))}onTransportError(transport,error){transport==this.transport&&(this.state=SocketStateEnum.ERRORED,this.emit("error",error))}}class Channel extends Events{topic;socket;state;timeout;joinPush;joinedOnce;rejoinRetry;joinTransport;pushBuffer=[];onMessage;constructor(topic,params,socket,options){if(super(),topic.includes(",")||topic.includes("*"))throw new Error("Commas and asterisks are not allowed in topic names");this.topic=topic,this.state=ChannelStateEnum.CLOSED,this.socket=socket,this.timeout=socket.getTimeout(),this.onMessage=options.onMessage||((_e,payload)=>payload),this.rejoinRetry=new Retry(()=>{socket.isConnected()&&this.rejoin()},socket.getRejoinInterval());let onSocketError=()=>{this.state=ChannelStateEnum.ERRORED,this.rejoinRetry.reset()};socket.on("error",onSocketError);let lastEndpoint,onSocketOpen=transport=>{this.rejoinRetry.reset(),(this.isErrored()||this.joinTransport&&(transport!=this.joinTransport||transport.endpoint()!=lastEndpoint))&&this.rejoin(),this.joinTransport=transport,lastEndpoint=transport.endpoint()};socket.on("open",onSocketOpen),this.joinPush=new Push(socket,this,"_join",params,this.timeout).on("ok",()=>{this.state=ChannelStateEnum.JOINED,this.rejoinRetry.reset(),this.pushBuffer.forEach(push=>push.send()),this.pushBuffer.splice(0),this.emit("join:ok")}).on("error",()=>{this.state=ChannelStateEnum.ERRORED,socket.isConnected()&&this.rejoinRetry.retry(),this.emit("join:error")}).on("timeout",()=>{log(CHANNEL,"timeout %s (%s)",topic,this.getJoinRef(),this.joinPush.getTimeout()),new Push(socket,this,"_leave",{},this.timeout).send(),this.state=ChannelStateEnum.ERRORED,this.joinPush.reset(),socket.isConnected()&&this.rejoinRetry.retry(),this.emit("join:timeout")}),this.onClose(()=>{this.isClosed()||(log(CHANNEL,"close %s %s",topic,this.getJoinRef()),socket.off("open",onSocketOpen),socket.off("error",onSocketError),this.rejoinRetry.reset(),this.state=ChannelStateEnum.CLOSED,socket.remove(this))}),this.onError(reason=>{log(CHANNEL,"error %s",topic,reason),this.isJoining()&&this.joinPush.reset(),this.state=ChannelStateEnum.ERRORED,socket.isConnected()&&this.rejoinRetry.retry()}),this.on("_reply",(payload,ref)=>{this.trigger("chan_reply_"+ref,payload)})}getTopic(){return this.topic}getJoinRef(){return this.joinPush.getRef()}join(timeout=this.timeout){if(this.joinedOnce)throw new Error("tried to join multiple times. 'join' can only be called a single time per channel instance");return this.timeout=timeout,this.joinedOnce=!0,this.rejoin(),this}rejoin(){this.isLeaving()||(this.socket.leave(this.topic),this.state=ChannelStateEnum.JOINING,this.joinPush.resend(this.timeout))}leave(timeout=this.timeout){this.rejoinRetry.reset(),this.joinPush.cancelTimeout(),this.state=ChannelStateEnum.LEAVING;var onClose=()=>{this.state==ChannelStateEnum.LEAVING&&(log(CHANNEL,"leave %s",this.topic),this.trigger("_close","leave"))};let leavePush=new Push(this.socket,this,"_leave",{},timeout,this.joinTransport).on("ok",onClose).on("timeout",onClose);return leavePush.send(),this.canPush()||queueMicrotask(()=>{leavePush.trigger("ok",{})}),leavePush}push(event,payload,timeout=this.timeout){if(event.includes(","))throw new Error("Commas are not allowed in event");if(payload=payload||{},this.joinedOnce)return payload=new Push(this.socket,this,event,payload,timeout),this.canPush()?payload.send():(payload.startTimeout(),this.pushBuffer.push(payload)),payload;throw new Error(`tried to push '${event}' to '${this.topic}' before joining. Use channel.join() before pushing events`)}trigger(event,payload,p_topic,ref,p_joinRef){if(!(p_topic&&this.topic!==p_topic||p_joinRef&&p_joinRef!==this.getJoinRef())){p_topic=this.onMessage(event,payload,ref,p_joinRef);if(payload&&!p_topic)throw new Error("channel onMessage callbacks must return the payload, modified or unmodified");this.emit(event,p_topic,ref,p_joinRef||this.getJoinRef())}}canPush(){return this.socket.isConnected()&&this.isJoined()}onClose(callback){return this.on("_close",callback),this.off.bind(this,"_close",callback)}onError(callback){return this.on("_error",callback),this.off.bind(this,"_error",callback)}isClosed(){return this.state===ChannelStateEnum.CLOSED}isErrored(){return this.state===ChannelStateEnum.ERRORED}isJoined(){return this.state===ChannelStateEnum.JOINED}isJoining(){return this.state===ChannelStateEnum.JOINING}isLeaving(){return this.state===ChannelStateEnum.LEAVING}}class Push{ref;sent;timer;timeout;socket;channel;received;refEvent;transport;event;events=new Events;payload;constructor(socket,channel,event,payload,timeout,transport){this.ref=socket.nextRef(),this.event=event,this.payload=payload||{},this.timeout=timeout,this.socket=socket,this.channel=channel,this.transport=transport}getRef(){return this.ref}getTimeout(){return this.timeout}on(event,callback){return this.hasReceived(event)?queueMicrotask(callback.bind(null,this.received.response)):this.events.on(event,callback),this}send(){this.hasReceived("timeout")||(this.startTimeout(),this.sent=!0,this.socket.push({ref:this.ref,joinRef:this.channel.getJoinRef(),topic:this.channel.getTopic(),event:this.event,payload:this.payload,payload_raw:""},this.transport))}resend(timeout){this.timeout=timeout,this.reset(),this.send()}reset(){this.channel.off(this.refEvent,this.onRefEventCallback),this.ref=void 0,this.sent=!1,this.refEvent=void 0,this.received=null}startTimeout(){this.timer&&this.cancelTimeout(),this.ref=this.socket.nextRef(),this.refEvent="chan_reply_"+this.ref,this.channel.on(this.refEvent,this.onRefEventCallback),this.timer=setTimeout(()=>{this.trigger("timeout",{})},this.timeout)}cancelTimeout(){clearTimeout(this.timer),this.timer=null}onRefEventCallback=payload=>{this.channel.off(this.refEvent,this.onRefEventCallback),this.cancelTimeout();var{status:payload,response}=this.received=payload;this.events.emit(payload,response)};hasReceived(status){return this.received&&this.received.status===status}trigger(status,response){this.channel.trigger(this.refEvent,{status:status,response:response})}}class TransportSSE extends Events{source;endpointRaw;endpointPush;endpointEvents;options;constructor(options){super(),this.options=options}send(data){fetch(this.endpointPush,{...this.options.cors?{mode:"cors",credentials:"include"}:{},method:"POST",headers:{"Content-Type":"application/json"},body:data}).catch(error=>{log(TRANSPORT,"send error",error,data)})}endpoint(){return this.endpointRaw}connect(endpoint){this.source&&this.endpointRaw==endpoint||(this.source&&this.source.close(),this.endpointRaw=endpoint,this.endpointPush=parseUrl(endpoint,"/sse",{sid:this.options.sid}),this.endpointEvents=parseUrl(endpoint,"/sse",{...this.options.params,sid:this.options.sid}),this.source=new EventSource(this.endpointEvents,{...this.options.cors?{withCredentials:!0}:{}}),this.source.onmessage=event=>{log(TRANSPORT,"message",event),this.emit("message",this,event.data)},this.source.onerror=event=>{log(TRANSPORT,"error",event),this.emit("error",this)},this.source.onopen=event=>{log(TRANSPORT,"open",event),this.emit("open",this)})}close(){this.source&&(log(TRANSPORT,"close"),this.source.close(),this.emit("close",this),this.source=null)}}let Transports={SSE:TransportSSE};class Retry{_tries=0;timeout;callback;intervals;intervalMax;constructor(callback,intervals){this.callback=callback,this.intervals=intervals.slice(0).sort(),this.intervalMax=Math.max(...this.intervals)}tries(){return this._tries}lastInterval(){return this.intervals[this._tries]||this.intervalMax}reset(){this._tries=0,clearTimeout(this.timeout)}retry(){clearTimeout(this.timeout),this.timeout=setTimeout(()=>{this._tries++,this.callback(this._tries)},this.intervals[this._tries]||this.intervalMax)}}function parseUrl(endpoint,suffix,params){var isHttp=endpoint.startsWith("http://"),isHttps=endpoint.startsWith("https://"),isProtocol=endpoint.startsWith("//"),endpoint=(isHttps?endpoint=endpoint.replace("https://",""):isHttp?endpoint=endpoint.replace("http://",""):isProtocol&&(endpoint=endpoint.replace("//","")),endpoint.split("?"));let basePath=(endpoint[0]+suffix).replaceAll(/[/]+/g,"/"),queryString=endpoint[1]||"";if(params)for(var key in params)0<queryString.length&&(queryString+="&"),queryString+=key+"="+encodeURIComponent(params[key]);return isHttps?basePath="https://"+basePath:isHttp?basePath="http://"+basePath:isProtocol&&(basePath="//"+basePath),""!=queryString?basePath+"?"+queryString:basePath}function encode(message){var{joinRef:message,ref,topic,event,payload}=message;return JSON.stringify([MessageKindEnum.PUSH,message,ref,topic,event,payload])}function decode(rawMessage){let[kind,joinRef,ref,topic,event,payload]=JSON.parse(rawMessage),countParts=5,payload_raw=(kind===MessageKindEnum.REPLY?(countParts=4,payload={status:0===topic?"ok":"error",response:event},event="_reply",topic=void 0):kind===MessageKindEnum.BROADCAST&&(countParts=3,payload=topic,event=ref,topic=joinRef,joinRef=ref=void 0),""),lastIndexOfComma=-1;for(let i=0;i<countParts&&-1!=(lastIndexOfComma=rawMessage.indexOf(",",lastIndexOfComma+1));i++);return-1!=lastIndexOfComma&&(payload_raw=rawMessage.substring(lastIndexOfComma+1,rawMessage.length-1)),{joinRef:joinRef,ref:ref,topic:topic,event:event,payload:payload,payload_raw:payload_raw,kind:kind}}let logGroupLen=Math.max(TRANSPORT.length,CHANNEL.length,SOCKET.length);function log(group,template,...params){"string"==typeof group&&!1===Options["Debug"+group]||(Options.Debug||"string"==typeof group&&Options["Debug"+group])&&("string"!=typeof template&&(params=[template,...params],template="","string"!=typeof group)&&(params=[group,...params],group=""),logGroupLen=Math.max(logGroupLen,group.length),console.log(("                           "+group).substr(-logGroupLen)+": "+template,...params))}class History{history={};ttlSeconds;constructor(ttlSeconds){this.ttlSeconds=Math.max(Math.round(ttlSeconds||5),1),setInterval(this.rotate.bind(this),1e3)}exists(key){let exists=!1;for(let i=0;i<this.ttlSeconds;i++){var slice=this.history["_"+i];if(slice&&slice[key]){exists=!0;break}}return this.history._0||(this.history._0={}),this.history._0[key]=!0,exists}rotate(){for(let i=this.ttlSeconds;0<i;i--){var secKey="_"+i;this.history[secKey]&&i==this.ttlSeconds&&delete this.history[secKey]}}}export{Options,MessageKindEnum,Events,Socket,Channel,Push,TransportSSE,Transports,Retry,encode,decode,log,History};